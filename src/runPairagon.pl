#!/usr/bin/perl -w

##################################################################
#   Copyright (c) 2006 Washington University, St. Louis, MO      #
#   All Rights Reserved                                          #
#   Send all comments to Mani - mozhiyan@cse.wustl.edu           #
#   Driver script for Pairagon v0.95 and up                      #
#   Driver version July 2006                                     #
##################################################################

package pairagon;

use strict;
use BPdeluxe;
use FAlite;
use File::Basename;
use Getopt::Long;


############################################
#          GLOBAL VARIABLES
#
# All the global variables are defined here. 
# This should be kept to a minimum. (Command
# line option variables excluded.)
############################################

my ($opt_amode, $opt_seqdb, $opt_outdir, $opt_exedir, $opt_genome, $opt_name, $opt_params, $opt_smode);
my ($opt_L, $opt_seedgen);
my ($opt_lowQ, $opt_seed, $opt_seedfile, $opt_debug, $opt_unopt, $opt_unseeded, $opt_nocleanup);

# $opt_lowQ is defined for future compatibility with qPairagon.
# It is not used anywhere.

# Only THREE non-command-line-option global variables for now

my $SCRIPT_NAME = "runPairagon.pl";
my $PROGRESS_FH;
my $DEBUG = 0;

############################################
# Help message
############################################

my $usage = "
$SCRIPT_NAME - A driver script for the Pairagon program

usage: $SCRIPT_NAME [options] <cdna> [<genomic>]

Program Options:
 --amode=<mode>             direction of cDNA sequence to align to the genomic sequence (forward|reverse|both, default:both)
 --smode=<mode>             direction of sense strand with respect to the genomic sequence
                            (forward = +, reverse = -, cdna = same strand as the cDNA, default: cdna)
 --seqdb=<seqdb>            seqdb (2bit, WU-BLASTN or GMAP) of all genomic sequences (only with --genome)
 --exedir=<directory>       directory where executables are located (default: \$HOME/bin)
 --genome=<directory>       directory where genomic files are located (only with --seqdb or --seedfile)
 --params=<file>            Pairagon's zoe HMM Parameter file (default: <exe_directory>/pairagon.zhmm)
 --unopt                    do not use the optimized viterbi (default: false)
 --seed=<program>           program for generating seed alignments (BLAT|GMAP|WUBLAST, default: BLAT)
 --seedfile=<file>          use seed alignment from <file> generated by <program> from --seed as the seed alignment. (BLAT and GMAP only).
 --unseeded                 do not use seeded alignment (Global optimal alignment can take a VERY LONG time to run)
                            - CANNOT be used with --genome and --seqdb (default: false)
  -L       <length>         extra length on each side of blast aligned region to 
			    be extracted for fine alignment (default: 10000)


Output Options:
 --outdir=<string>          Specify Directory for output file (default: <pwd>/output)
 --name=<string>            Instance name (Alignment will be in <output_dir>/<instance_name>.estgen)
 --nocleanup                do not clean up temporary files at the end. 
                            Normally only the <instance_name>.{seed,pair,estgen,progress} files remain.
 --seedgen                  only generate a seed alignment file, then stop. 

Debug Options:
 --debug   <number>         prints out messages to debug
";

############################################
# Begin Execution
############################################

GetOptions(
	"L=n" => \$opt_L,
	"-seedgen"    => \$opt_seedgen,
	"-smode=s"    => \$opt_smode,
	"-amode=s"    => \$opt_amode,
	"-name=s"     => \$opt_name,
	"-params=s"   => \$opt_params,
	"-genome=s"   => \$opt_genome,
	"-exedir=s"   => \$opt_exedir,
	"-outdir=s"   => \$opt_outdir,
	"-seqdb=s"    => \$opt_seqdb,
	"-seed=s"     => \$opt_seed,
	"-seedfile=s" => \$opt_seedfile,
	"-debug=n"    => \$opt_debug,
	"-unopt"      => \$opt_unopt,
	"-unseeded"   => \$opt_unseeded,
	"-nocleanup"  => \$opt_nocleanup
);
if ((!$opt_genome && @ARGV < 2) ||
    ( $opt_genome && @ARGV < 1)) {
	die $usage;
}

run_me(@ARGV);
exit(0);

############################################
# End Execution
############################################


sub run_me {

	############################################
	#          run_me() VARIABLES
	#
	# All the run_me() variables are defined here. There
	# should not be any definition inside the
	# main function, except for iterators and
	# fully local variables (scope is within 10
	# lines). All run_me() variables are UPPER
	# case and local variables are lower case
	############################################

	# Arguments
	my ($CDNA, $GENOMIC, $QUALITY);

	# File names
	my ($QUALITY_FILE);
	my $HMM_FILE;
	my $SEED_FILE;
	my $PROGRESS_FILE;
	my $SEQ_DB;
	my $OUTPUT_DIR;
	my $EXE_DIR;
	my $GENOMIC_DIR;

	# Instance name
	my $NAME;

	# Seed alignment
	my $SEED_PROGRAM;
	my $INSEED_FILE;

	# Program options
	my $EXTRA_GENOMIC;
	my $ALIGNMENT_MODE;
	my $SPLICE_MODE;
	my $OUTPUT_MODE;
	my $OPTIMIZED_MODE;
	my $SEEDED_MODE;
	my $CLEANUP;
	my $MAX_INTRON_LENGTH = 1000000;

	# Seeds
	my %SEEDS     = ();
	my @CDNA_DEFS = ();

	############################################
	# Grab arguments
	############################################

	($CDNA, $GENOMIC, $QUALITY) = @_;
	
	############################################
	# Set file names from command line options
	############################################


	$SEED_PROGRAM   = "BLAT";   # Change this to whatever program you want 
					# and implement a function to generate seed
					# alignments from its output

	$INSEED_FILE    = undef;
	$NAME           = basename($CDNA);
	$EXE_DIR        = $ENV{"HOME"}."/bin/";
	$OUTPUT_DIR     = "output";
	$SEQ_DB         = undef;
	$GENOMIC_DIR    = undef;
	$EXTRA_GENOMIC  = 10000;
	$ALIGNMENT_MODE = undef;
	$SPLICE_MODE    = "cdna";
	$OPTIMIZED_MODE = "-o";
	$OUTPUT_MODE    = "-i";
	$SEEDED_MODE    = 1;
	$CLEANUP        = 1;

	# Long command line options

	if ($opt_amode)  {$ALIGNMENT_MODE = $opt_amode;}
	if ($opt_seqdb)  {$SEQ_DB         = $opt_seqdb;}
	if ($opt_outdir) {$OUTPUT_DIR     = $opt_outdir;}
	if ($opt_exedir) {$EXE_DIR        = $opt_exedir;}
	if ($opt_genome) {$GENOMIC_DIR    = $opt_genome;}
	if ($opt_name)   {$NAME           = $opt_name;}
	if ($opt_smode)  {$SPLICE_MODE    = $opt_smode;}
	if ($opt_L)      {$EXTRA_GENOMIC  = $opt_L;}

	$HMM_FILE       = "$EXE_DIR/pairagon.zhmm";
	if ($opt_params) {$HMM_FILE       = $opt_params;}

	if ($opt_seed)     {$SEED_PROGRAM   = $opt_seed;}
	if ($opt_seedfile) {$INSEED_FILE    = $opt_seedfile;}
	if ($opt_debug)    {$DEBUG          = $opt_debug;}
	if ($opt_unopt)    {$OPTIMIZED_MODE = "";}
	if ($opt_unseeded) {$SEEDED_MODE    = 0;}
	if ($opt_nocleanup){$CLEANUP    = 0;}

	$PROGRESS_FILE  = "$OUTPUT_DIR/$NAME.progress";
	$SEED_FILE      = "$OUTPUT_DIR/$NAME.seed";


	############################################
	# Check integrity of the command line
	############################################

	if ($SEED_PROGRAM ne "WU-BLAST" && $SEED_PROGRAM ne "BLAT" && $SEED_PROGRAM ne "GMAP") {
		die "Only the following seed alignment programs are available:\nWU-BLAST, BLAT, GMAP\n";
	}

	if ((($opt_seqdb || $opt_seedfile) && !$opt_genome) || (!($opt_seqdb || $opt_seedfile) && $opt_genome)) {
		die "--seqdb or --seedfile must be used with --genome\n";
	}

	if ($opt_genome) {
		if (defined($GENOMIC)) {
			print "# Ignoring $GENOMIC since --genome is set\n";
		}
		$GENOMIC = undef;
	}

	if ($SEEDED_MODE == 0 && ($opt_seqdb || $opt_genome)) {
		die "Unseeded alignment should be run on a single (and reasonably short) genomic sequence. Do not use --seqdb and --genome\n";
	}

	############################################
	# Check integrity of the input files
	############################################

	my $fasta_status;
	($fasta_status, @CDNA_DEFS) = get_valid_fasta_entries($CDNA);
	if ($fasta_status == -1) {
		print "# Non [A,C,G,T,N] letters in input file $CDNA\n";
		print "# These will be converted to N\n";
		create_clean_fasta_entries($CDNA, "$OUTPUT_DIR/$NAME.cdna.fa.modified");
		$CDNA = "$OUTPUT_DIR/$NAME.cdna.fa.modified";
		($fasta_status, @CDNA_DEFS) = get_valid_fasta_entries($CDNA);
	}

	############################################
	# Don't do this for genomic sequences since
	# you will be reading and writing huge
	# files. Pairagon can convert non-ACGTN to N
	# internally now.
	############################################

	$fasta_status = undef; # End my scope

	open(PROGRESS, ">$PROGRESS_FILE") || die "Cannot open progress file $PROGRESS_FILE: $!";
	$PROGRESS_FH = \*PROGRESS;
	print $PROGRESS_FH "# Started  at ".get_today()." on ".get_hostname()."\n";

	####################################################
	# I should make this object oriented at some point!
	# Done: 07/18/06
	####################################################

	my $aligner;
	if ($SEEDED_MODE != 0) {
		my %object_elements = (
					'PROGRAM'           => $SEED_PROGRAM,
					'SEQDB'             => $SEQ_DB,
					'GENOMIC_DIR'       => $GENOMIC_DIR,
					'QUERY'             => $CDNA,
					'TARGET'            => $GENOMIC,
					'OUTPUT_DIR'        => $OUTPUT_DIR,
					'INSTANCE_NAME'     => $NAME,
					'MAX_INTRON_LENGTH' => $MAX_INTRON_LENGTH,
					'EXTRA_GENOMIC'     => $EXTRA_GENOMIC,
					'SHOULD_ALIGN'      => ($INSEED_FILE)?0:1,
					'INSEED_FILE'       => $INSEED_FILE
				      );
		if ($SEED_PROGRAM eq "WU-BLAST") {
			$aligner = pairagon::wublast->new(%object_elements);
		} elsif ($SEED_PROGRAM eq "BLAT") {
			$aligner = pairagon::blat->new(%object_elements);
		} elsif ($SEED_PROGRAM eq "GMAP") {
			$aligner = pairagon::gmap->new(%object_elements);
		}
		$aligner->run;
		%SEEDS = %{$aligner->global_seed};

		if (scalar(keys %SEEDS) == 0) {
			print "# Cannot find seed alignments for $CDNA\n";
			print $PROGRESS_FH "# Cannot find seed alignments for $CDNA\n";
			print $PROGRESS_FH "# Finished at ".get_today()." on ".get_hostname()."\n";
			exit(-1);
		}

		foreach my $cdna (sort keys %SEEDS) {
			my $loci = scalar(keys %{$SEEDS{$cdna}});
			if ($loci > 1) {
				print "# Loci found for $cdna: $loci\n";
				print $PROGRESS_FH "# Loci found for $cdna: $loci\n";
			}
			foreach my $hit (sort keys %{$SEEDS{$cdna}}) {
				#################################################
				# Filter the alignment and write to SEED file
				#################################################

				my $seed_ref = $SEEDS{$cdna}{$hit};
				my $extra_genomic     = $aligner->extra_genomic;
				my $max_intron_length = $aligner->max_intron_length;

				pairagon::utility::filter_seed_alignment($max_intron_length, $seed_ref);
				print STDERR "# Generating seed alignment file\n";
				print $PROGRESS_FH "# Generating seed alignment file\n";
				open(FH, ">$SEED_FILE") || die "Cannot open $SEED_FILE: $!";
				pairagon::utility::print_seed(\*FH, $cdna, $extra_genomic, %$seed_ref);
				close(FH);

				if ($opt_seedgen) {
					print "# Seed alignment is in $SEED_FILE\n";
					print $PROGRESS_FH "# Finished at ".get_today()." on ".get_hostname()."\n";
					exit(0);
				}

				#################################################
				# Get the right genomic file from seed alignment 
				#################################################

				if (defined($GENOMIC_DIR)) {
					my $genomic  = $seed_ref->{"subject"};
					$GENOMIC     = "$GENOMIC_DIR/$genomic.fa";

					print "# Aligning to locus $hit in $GENOMIC\n";
					print $PROGRESS_FH "# Aligning to locus $hit in $GENOMIC\n";

				} else {
					print "# Aligning to locus $hit in $GENOMIC\n";
					print $PROGRESS_FH "# Aligning to locus $hit in $GENOMIC\n";
				}

				############################################
				# Run Pairagon
				############################################

				my $instance_name = "$NAME.$hit";
				my $pairagon = pairagon::instance->new(
						'PROGRAM_DIR'    => $EXE_DIR,
						'HMM_FILE'       => $HMM_FILE,
						'CDNA'           => $CDNA,
						'GENOMIC'        => $GENOMIC,
						'OUTPUT_DIR'     => $OUTPUT_DIR,
						'OPTIMIZED_MODE' => $OPTIMIZED_MODE,
						'OUTPUT_MODE'    => $OUTPUT_MODE,
						'ALIGNMENT_MODE' => $ALIGNMENT_MODE,
						'SPLICE_MODE'    => $SPLICE_MODE,
						'INSTANCE_NAME'  => $instance_name
						);
				if (-f $SEED_FILE) {
					$pairagon->{SEED} = $SEED_FILE;
				} else {
					die "Seed alignment could not be generated. Check $PROGRESS_FILE for details";
				}
				$pairagon->check_executables;
				$pairagon->run;
				print "# Alignment is in ".$pairagon->estgen_output_file."\n";
				print $PROGRESS_FH "# Alignment is in ".$pairagon->estgen_output_file."\n";
			}
		}
	}


	if ($CLEANUP == 1) {
		$aligner->clean_up;
	}

	print $PROGRESS_FH "# Finished at ".get_today()." on ".get_hostname()."\n";
	close(PROGRESS);
}

############################################
############################################
##       Subroutines
############################################
############################################

sub get_today {
	return scalar localtime();
}

# For lack of a faster and better way, it calls UNIX hostname.
# Feel free to fix it.

sub get_hostname {
	my $string = `hostname`;
	chomp($string);
	return $string;
}

#####################################################################
# Check validity of fasta file
#####################################################################

sub get_valid_fasta_entries {
	my ($file) = @_;
	my @defs   = ();
	my $count  = 0;
	pairagon::utility::print_debug(5, "get_valid_fasta_entries", "Trying to open $file");
	open(SEQ, "<$file") || die "Cannot open $file: $!";
	my $fasta = new FAlite(\*SEQ);
	while (my $entry = $fasta->nextEntry) {
		my $def = $entry->def;
		$def =~ s/ .*//g;
		$def =~ s/>//;
		$count++;
		push(@defs, $def);
		pairagon::utility::print_debug(5, "get_valid_fasta_entries", "Checking entry $count: ".$entry->def);
		if ($entry->seq =~ /[^acgtnACGTN]/) {
			return -1;
		}
	}
	if ($count == 0) {
		die "Invalid fasta file: $file";
	}
	close(SEQ);
	return ($count, @defs);
}

sub create_clean_fasta_entries {
	my ($old_file, $new_file) = @_;
	open (ORIGINAL, "<$old_file") || die "Cannot open $old_file";
	open (MODIFIED, ">$new_file") || die "Cannot open $new_file for modified cDNA";
	my $fasta = new FAlite(\*ORIGINAL);
	while (my $entry = $fasta->nextEntry) {
		my $def = $entry->def;
		my $seq = $entry->seq;
		if ($seq =~ /[^acgtnACGTN]/) {
			$seq =~ s/[^acgtnACGTN]/N/g;
		}
		print MODIFIED "$def\n$seq\n";
	}
	close(ORIGINAL);
	close(MODIFIED);
}

############################################
#        Utility Functions
############################################

{
package pairagon::utility;

# Uses the global variable $DEBUG

sub print_debug {
	my ($level, $subroutine, $message) = @_;
	if ($DEBUG >= $level) {
		printf "%50s:\t%s\n", $subroutine, $message;
	}
}

#####################################################################
# If the coordinates of hsp begin position are monotonic
#####################################################################

sub compatible_hsp {
	return (sort_genomic(@_) eq 
	        sort_cdna(@_));
}

sub sort_genomic {
	my (@list) = @_;
	@list = sort {($a->sb) <=> ($b->sb)} @list;
	return @list;
}

sub sort_cdna {
	my (@list) = @_;
	@list = sort {$a->qb <=> $b->qb} @list;
	return @list;
}

############################################
#  HSP object handler
############################################

#####################################################################
# Checks if an hsp is valid. Validity is defined as:
#  >96% identity for high quality sequence 
#      or >93% for low quality sequences, hsp->length >= 100
#      or >95% for low quality sequences, hsp->length < 100
#  and <50% A and T bases in the hsp
#  and 100% if hsp->length < 30
#####################################################################

sub hsp_validity {
	my ($hsp, $cdna_length) = @_;

	# 96% for high quality sequence only. If you suspect 
	# low quality sequence, lower the threshold

	if ((!$opt_lowQ && $hsp->percent < 96) ||
	    ($hsp->length < 100 && $hsp->percent < 95) ||
	    ($hsp->length >= 100 && $hsp->percent < 93)) {
		return -1;
	}

	#Ignore polyA and polyT stretches for pin generation

	my $polyA_p = 0.5;
	my $query = $hsp->queryAlignment;
	$query =~ s/A//ig;
	if ((length $query) < (1 - $polyA_p) * (length $hsp->queryAlignment)) {
		return -1;
	}

	$query = $hsp->queryAlignment;
	$query =~ s/T//ig;
	if ((length $query) < (1 - $polyA_p) * (length $hsp->queryAlignment)) {
		return -1;
	}

	# Short exons - should not have any mismatches. If they do, skip them
	if ($hsp->length < 30 && $hsp->percent != 100) {
		return -1;
	}

	# Short terminal exons should actually be terminal
	if ($hsp->length < 20 && ($hsp->qb > 0.2*$cdna_length || $hsp->qe < 0.8*$cdna_length)) {
		return -1;
	}

	return 1;
}

############################################
#  Seed alignment hash handler
############################################

sub print_seed {
	my ($file_handler, $cdna, $offset, %seeds) = (@_);
	my ($subject, $sub_len, $score, $strand, $gb_start, $gb_end, $hsp_ref, @hsps);

	$subject  = $seeds{"subject"};
	$strand   = $seeds{"strand"};
	$gb_start = $seeds{"gb_start"};
	$gb_end   = $seeds{"gb_end"};
	$hsp_ref  = $seeds{"hsps"};
	$sub_len  = $seeds{"sublen"};
	@hsps     = @$hsp_ref;

	if (defined($offset)) {
		if ($gb_start - $offset > 0) {
			$gb_start -= $offset;
		} else {
			$gb_start = 1;
		}
		if ($gb_end + $offset < $sub_len) {
			$gb_end += $offset;
		} else {
			$gb_end = $sub_len;
		}
	}

	print $file_handler ">$cdna\n";
	print $file_handler "genomic_boundary_start=$gb_start genomic_boundary_end=$gb_end strand=$strand subject=$subject\n";
	print $file_handler "count=".(scalar @hsps)."\n";
	foreach my $hsp (@hsps) {
		print $file_handler "$hsp\n";
	}
}

sub generate_seed_alignment_file {
	my ($aligner, %seeds) = (@_);
	my $seed_file = $aligner->output_dir."/".$aligner->instance_name.".seed";
	my $extra_genomic = $aligner->extra_genomic;
	my $max_intron_length = $aligner->max_intron_length;
	open(FH, ">$seed_file") || die "Cannot open $seed_file: $!";
	my ($cdna) = (sort keys %seeds);
		my $seed_set = $seeds{$cdna};
		foreach my $hit (sort keys %$seed_set) { # Each hit from the seed program
			my $seed = $seeds{$cdna}{$hit};
			filter_seed_alignment($max_intron_length, $seed);
			print_seed(\*FH, $cdna, $extra_genomic, %$seed);
		}
	close(FH);
}

##########################################################################################################
# Makes sure that there isn't a VERY LONG gap in the seed alignment that is too long to be an intron.
# If there is one or more such gaps, this chooses the largest contiguous set of HSPs without such a gap.
# Remember that the reference to the hash is passed here so that you can change the seed alignment here.
##########################################################################################################
sub filter_seed_alignment {
	my ($intron_limit, $seeds_ref) = @_;
	my $hsp_ref  = $seeds_ref->{"hsps"};
	my @hsps     = @$hsp_ref;
	my @long_breaks = ();
	my @new_hsps = ();

	#########################################################
	# Check for long gaps, and store the index of such a gap
	#########################################################

	push(@long_breaks, 0);
	for (my $i = 1; $i <= $#hsps; $i++) {
		if ($hsps[$i]->sb - $hsps[$i-1]->se > $intron_limit) {
			push(@long_breaks, $i);
		}
	}
	push(@long_breaks, scalar(@hsps));

	if (scalar(@long_breaks) == 2) {
		# Fine, do nothing
	} else {
		##########################################################################################################
		# There is at least one long intron in here. Need to choose a section that does not include a long intron. 
		# Choose the set with the most HSPs without long gaps
		##########################################################################################################

		print STDERR "# One or more gaps longer than $intron_limit found in the seed alignment.\n";
		print STDERR "# Using the largest subset of contiguous HSPs without such a gap.\n";
		print $PROGRESS_FH "# One or more gaps longer than $intron_limit found in the seed alignment.\n";
		print $PROGRESS_FH "# Using the largest subset of contiguous HSPs without such a gap.\n";

		my $best_break = 0;
		my $best_size  = -1;
		for (my $i = 1; $i <= $#long_breaks; $i++) {
			if ($long_breaks[$i] - $long_breaks[$i-1] > $best_size) {
				$best_size = $long_breaks[$i] - $long_breaks[$i-1];
				$best_break = $i;
			}
		}

		##########################################################################################################
		#chop from $long_breaks[$best_break-1] to $long_breaks[$best_break]-1
		# Get that new set
		##########################################################################################################

		for (my $i = $long_breaks[$best_break-1]; $i < $long_breaks[$best_break]; $i++) {
			push(@new_hsps, $hsps[$i]);
		}
		$seeds_ref->{"hsps"} = \@new_hsps;
		$seeds_ref->{"gb_start"}= $new_hsps[0]->sb;
		$seeds_ref->{"gb_end"}  = $new_hsps[$#new_hsps]->se;
	}
}
1;
}

############################################
#  Generic seed alignment program handler
#  The SUPER class
############################################

{
package pairagon::aligner;
use strict;

sub new {
	my $class  = shift;
	my %params = @_;
	bless {
		%params
	}, $class;
}

sub check_executables {
	my $aligner     = shift;
	my $program     = $aligner->program;
	my @executables = $aligner->get_executables;
	for my $exe (@executables) {
	# 127 - UNIX exit code when program not found
		if (system("$exe 1>/dev/null 2>/dev/null") == 127) {
			die "$exe program in $program package not found in path";
		}
	}
}

sub check_seqdb {
	my $aligner = shift;
	my $program = $aligner->program;
	my $seqdb   = $aligner->seqdb;
	my $cmdline = $aligner->get_check_seqdb_cmdline;
	if (system("$cmdline") != 0) {
		die "$seqdb is not a valid $program nucleotide database\n";
	}
}

sub validate_files {
	my $aligner = shift;
	$aligner->check_executables;
	if ($aligner->should_align == 1) {
		$aligner->check_seqdb;
	}
}

sub run {
	my $aligner = shift;
	my $program = $aligner->program;

	print STDERR "# Checking $program executables\n";
	print $PROGRESS_FH "# Checking $program executables\n";
	$aligner->validate_files;

	if ($aligner->should_align == 1) {
		print STDERR "# Seeding with $program\n";
		print $PROGRESS_FH "# Seeding with $program\n";
		$aligner->align;
	} else {
		print STDERR "# Selecting relevant alignments from ".$aligner->inseed_file."\n";
		print $PROGRESS_FH "# Selecting relevant alignments from ".$aligner->inseed_file."\n";
		$aligner->grep_alignment;
	}

	print STDERR "# Processing $program outputs\n";
	print $PROGRESS_FH "# Processing $program outputs\n";
	$aligner->process_output;
}

sub program       { shift->{PROGRAM}}
sub seqdb         { shift->{SEQDB}}
sub genomic_dir   { shift->{GENOMIC_DIR}}
sub instance_name { shift->{INSTANCE_NAME}}
sub query         { shift->{QUERY}}
sub target        { shift->{TARGET}}
sub genomic       { shift->target}
sub output_dir    { shift->{OUTPUT_DIR}}
sub global_seed   { shift->{GLOBAL_SEED}}
sub extra_genomic { shift->{EXTRA_GENOMIC}}
sub should_align  { shift->{SHOULD_ALIGN}}
sub inseed_file   { shift->{INSEED_FILE}}
sub max_intron_length { shift->{MAX_INTRON_LENGTH}}

# MUST be implemented by the child
sub get_executables {}
sub get_check_seqdb_cmdline {}
sub generate_seqdb {
	die "This version of the driver cannot generate sequence database for ".(shift->program).". Try using --seqdb instead\n";
}
sub grep_alignment {
	die "This version of the driver cannot use external batch alignment from ".(shift->program).". Do not use --seedfile\n";
}
#sub align {}

1;
}

############################################
#  BLAT program handler
############################################

{
package pairagon::blat;
use base("pairagon::aligner");
use strict;

sub new {
	my $class  = shift;
	my %params = @_;
	my $self   = $class->SUPER::new(@_);
	if (!defined($self->seqdb) && $self->should_align == 1) {
		print STDERR "# Generating sequence database for ".$self->genomic."\n";
		$self->generate_seqdb;
	}
	return $self
}

sub get_executables {return qw(blat twoBitInfo pslSort pslCDnaFilter);}

sub get_check_seqdb_cmdline {
	my $self = shift;
	return "twoBitInfo ".$self->seqdb." /dev/null"; 
}

sub generate_seqdb {
	my $aligner = shift;
	my $seqdb   = $aligner->output_dir."/".$aligner->instance_name.".2bit";
	my $genomic = $aligner->genomic;
	my $cmdline = "faToTwoBit $genomic $seqdb";
	if ((my $err_code = system("$cmdline")) != 0) {
		die "BLAT:faToTwoBit failed with error code: $err_code\n";
	}
	$aligner->{SEQDB} = $seqdb;
}

sub get_executable { "blat"}

sub get_parameters {
	"-q=rna -fine -repeats=lower -noHead -trimT"
	#-ooc=11.ooc";#
}

sub get_output {
	my $aligner = shift;
	return $aligner->output_dir."/".$aligner->instance_name.".psl";
}

sub get_command_line {
	my $aligner = shift;
	my $exe     = $aligner->get_executable;
	my $params  = $aligner->get_parameters;
	my $seqdb   = $aligner->seqdb;
	my $query   = $aligner->query;
	my $output  = $aligner->get_output;
	return "$exe $params $seqdb $query $output";
}

# Align the cDNA and get the PSL
sub align {
	my $aligner = shift;
	my $cmdline = $aligner->get_command_line;
	my $program = $aligner->program;
	print $PROGRESS_FH "$cmdline\n";
	if ((my $err_code = system("$cmdline 1>/dev/null 2>/dev/null")) != 0) {
		die "$program failed with error code: $err_code\n";
	}
}

# Alignment is there, just use it!
sub grep_alignment {
	my $aligner = shift;
	my $inseed_file  = $aligner->inseed_file;
	my $outseed_file = $aligner->get_output;
	my $query        = $aligner->instance_name;
	my @psl_lines    = ();
	open(PSL, "<$inseed_file") || die "Cannot open PSL file $inseed_file: $!";
	@psl_lines = <PSL>;
	# 10th column is the qName
	@psl_lines = grep { (split(/\t+/, $_))[9] eq $query } @psl_lines;
	open(SEED, ">$outseed_file") || die "Cannot open seed file $outseed_file: $!";
	print SEED @psl_lines;
	close(SEED);
	close(PSL);
}

sub process_output {
	my $aligner = shift;
	my $output  = $aligner->get_output;
	my $query   = $aligner->instance_name;

	my $filtered_output = "$output.filter";

	my %seed       = ();
	my $seed_count = 0;
	my @psl_lines  = ();

	# use pslSort and pslCDnaFilter to filter all your alignments
	(system("pslCDnaFilter -minId=0.96 -minCover=0.25 -localNearBest=0.001 -minQSize=20 -minNonRepSize=16 -ignoreNs -bestOverlap $output $filtered_output 1>/dev/null 2>/dev/null") == 0) || die "pslCDnaFilter failed";

	open(PSL, "<$filtered_output") || die "Cannot open PSL file $filtered_output: $!";
	@psl_lines = <PSL>;
	@psl_lines = grep { $_ =~ /($query)/ } @psl_lines;
	print STDERR "# ".scalar(@psl_lines)." seed alignment(s) found for $query\n";
	print $PROGRESS_FH "# ".scalar(@psl_lines)." seed alignment(s) found for $query\n";
	foreach my $line (@psl_lines) {
		chomp($line);
		my @words = split(/\s+/, $line);
		my ($strand, $query, $template, $tSize, $tBegin, $tEnd, $blocks, $blockSize, $qStart, $tStart) = ($words[8], $words[9], $words[13], $words[14], $words[15], $words[16], $words[17], $words[18], $words[19], $words[20]);
		my @blockSizes = split(/,/, $blockSize);
		my @qStarts    = split(/,/, $qStart);
		my @tStarts    = split(/,/, $tStart);
		my @hsps       = ();
		$tBegin++;

		# Specific to GMAP
		# Since GMAP outputs chrNNXXYY as NNXXYY in PSL format, we need to add "chr".
		# The other option is to change the coords.<DB> file in GMAP db, and add the
		# string "chr" manually, but you can't really expect users to do that. In this
		# case, if it has been fixed already, it doesn't add "chr" anyway. 

		if ($template !~ /^chr/ ) {
			$template = "chr$template";
		}

		for (my $i = 0; $i < $blocks; $i++) {
			my $hsp_object = pairagon::hsp::new($template, $tStarts[$i]+1, $tStarts[$i]+$blockSizes[$i], $qStarts[$i]+1, $qStarts[$i]+$blockSizes[$i], 0, 0);
			push(@hsps, $hsp_object);
		}
		@hsps = pairagon::utility::sort_genomic(@hsps);
		$seed{$query}{$seed_count}{"subject"} = $template;
		$seed{$query}{$seed_count}{"sublen"}  = $tSize;
		$seed{$query}{$seed_count}{"strand"}  = $strand;
		$seed{$query}{$seed_count}{"gb_start"}= $tBegin+1;
		$seed{$query}{$seed_count}{"gb_end"}  = $tEnd;
		$seed{$query}{$seed_count}{"hsps"}    = \@hsps;
		$seed_count++;
	}
	close(PSL);
	$aligner->{GLOBAL_SEED} = \%seed;
}

sub clean_up {
	my $aligner = shift;
	my $prefix  = $aligner->output_dir."/".$aligner->instance_name;
	foreach my $suffix qw(psl psl.filter) {
		system("rm $prefix.$suffix");
	}
}

1;
}

{
package pairagon::gmap;
use base qw(pairagon::blat pairagon::aligner);
use strict;

sub new {
	my $class  = shift;
	my %params = @_;
	my $self   = $class->SUPER::new(@_);
	if (!defined($self->seqdb) && $self->should_align == 1) {
		$self->generate_seqdb;
	}
	return $self
}

sub get_executables {return qw(gmap);}

sub get_check_seqdb_cmdline {
	my $self = shift;
	return "ls ".$self->seqdb.".* 1>/dev/null 2>/dev/null"; 
}

sub get_executable { "gmap"}

sub get_parameters { "-f 1 " }
# consider using -B 2 for batch mode

sub get_command_line {
	my $aligner = shift;
	my $exe     = $aligner->get_executable;
	my $params  = $aligner->get_parameters;
	my $seqdb   = $aligner->seqdb;
	my $dbdir   = File::Basename::dirname($seqdb);
	my $dbname  = File::Basename::basename($seqdb);
	my $query   = $aligner->query;
	my $output  = $aligner->get_output;
	return "$exe $params -D $dbdir -d $dbname $query > $output";
}

1;
}

############################################
#  WU-BLAST program handler
############################################

{
package pairagon::wublast;
use base("pairagon::aligner");
use strict;

sub new {
	my $class  = shift;
	my %params = @_;
	my $self   = $class->SUPER::new(@_);
	if (!defined($self->seqdb)) {
		$self->generate_seqdb;
	}
	return $self
}

sub get_executables { return qw(blastn xdformat);}

sub get_check_seqdb_cmdline { 
	my $self = shift;
	return "xdformat -n -V ".$self->seqdb." 1>/dev/null 2>/dev/null";
}

sub get_executable { return "blastn";}

sub get_parameters {
	my $parameters;
	$parameters  = "B=10000 V=100 -gi -cpus=1 -warnings ";
	$parameters .= "-nogap -topComboN=4 -span1 ";
	$parameters .= "M=1 N=-20 E=1e-10";  # This is specific to high quality sequences. If not, you might want to use N=-3 or something
	return $parameters;
}

sub get_output {
	my $aligner = shift;
	return $aligner->output_dir."/".$aligner->instance_name.".blast";
}

sub get_command_line {
	my $aligner = shift;
	my $exe     = $aligner->get_executable;
	my $params  = $aligner->get_parameters;
	my $seqdb   = $aligner->seqdb;
	my $query   = $aligner->query;
	return "$exe $seqdb $query $params";
}

sub generate_seqdb {
	my $aligner = shift;
	my $seqdb   = $aligner->output_dir."/".$aligner->instance_name;
	my $genomic = $aligner->genomic;
	my $cmdline = "xdformat -nI -o $seqdb $genomic";
	if ((my $err_code = system("$cmdline")) != 0) {
		die "WU-BLAST:xdformat failed with error code: $err_code\n";
	}
	$aligner->{SEQDB} = $seqdb;
}

sub align {
	my $aligner = shift;
	my $output  = $aligner->output_dir."/".$aligner->instance_name;
	my $cmdline = $aligner->get_command_line;
	print $PROGRESS_FH "$cmdline -top    > $output.fwd.blast\n";
	if ((my $err_code = system("$cmdline -top    > $output.fwd.blast")) != 0) {
		die "WU-BLAST:blastn failed with error code: $err_code\n";
	}
	print $PROGRESS_FH "$cmdline -bottom > $output.rev.blast\n";
	if ((my $err_code = system("$cmdline -bottom > $output.rev.blast")) != 0) {
		die "WU-BLAST:blastn failed with error code: $err_code\n";
	}
}

sub process_output {
	my $aligner = shift;
	my $output  = $aligner->output_dir."/".$aligner->instance_name;
	my %fwd_seeds  = $aligner->process_blast_output_file("$output.fwd.blast", "+");
	my %rev_seeds  = $aligner->process_blast_output_file("$output.rev.blast", "-");
	my %merged_seeds = (%fwd_seeds, %rev_seeds);
	my %seed = ();
	my $alignable = 0;

	# Choose the top loci from both + and -

	foreach my $cdna (sort keys %merged_seeds) { # Assuming even empty alignments make it to the hash
		my $max_score = 0;
		my %fwd_seed;
		my %rev_seed;
		my $seed_count;

		if (defined($fwd_seeds{$cdna})) {
			%fwd_seed = %{$fwd_seeds{$cdna}};
			foreach my $index (sort keys %fwd_seed) {
				if ($fwd_seed{$index}{"score"} > $max_score) {
					$max_score = $fwd_seed{$index}{"score"};
				}
			}
		}
		if (defined($rev_seeds{$cdna})) {
			%rev_seed = %{$rev_seeds{$cdna}};
			foreach my $index (sort keys %rev_seed) {
				if ($rev_seed{$index}{"score"} > $max_score) {
					$max_score = $rev_seed{$index}{"score"};
				}
			}
		}

		$seed_count = 0;
		if (defined($fwd_seeds{$cdna})) {
			foreach my $index (sort keys %fwd_seed) {
				if ($fwd_seed{$index}{"score"} > 0.95*$max_score) {
					foreach my $key (sort keys %{$fwd_seed{$index}}) {
						$seed{$cdna}{$seed_count}{$key} = $fwd_seed{$index}{$key};
					}
					$seed_count++;
				}
			}
		}
		if (defined($rev_seeds{$cdna})) {
			foreach my $index (sort keys %rev_seed) {
				if ($rev_seed{$index}{"score"} > 0.95*$max_score) {
					foreach my $key (sort keys %{$rev_seed{$index}}) {
						$seed{$cdna}{$seed_count}{$key} = $rev_seed{$index}{$key};
					}
					$seed_count++;
				}
			}
		}
		if ($seed_count != 0) {
			$alignable = 1;
		}
		#pairagon::utility::print_seed(\*STDOUT, $cdna, 10000, $seed{1});
	}
	if ($alignable != 1) {
		%seed = ();
	}
	$aligner->{GLOBAL_SEED} = \%seed;
}

# Get a seed alignment for each cDNA sequence in the blast output file
# Return value is a hash containing details about each seed alignment
sub process_blast_output_file {
	my $aligner         = shift;
	my ($file, $strand) = @_;
	open(BLAST, "<$file") || die "Cannot open blast output file $file: $!";
	my $blast = new BPdeluxe::Multi(\*BLAST);
	my %seed = ();
	pairagon::utility::print_debug(5, "process_blast_output_file", "Reading $strand strand BLASTN output file");
	while (my $report = $blast->nextReport) {
		my $cdna         = $report->query;
		my $queryLength  = $report->queryLength;
		my $best_sub_len = 0;
		my $best_score   = 0;
		my @best_hsps    = ();
		my @HSPS         = ();
		my %eligible_subjects = ();

		$cdna =~ s/ .*//;
		pairagon::utility::print_debug(5, "process_blast_output_file", "Query = $cdna");

		while (my $subject = $report->nextSbjct) {
			my $max_group = 0;
			my @hsps      = ();
			my $subject_name = $subject->name;
			$subject_name =~ s/>//;
			$subject_name =~ s/ .*//;

			# Sort the HSPs by group and then by subjectBegin to get max_group

			while (my $hsp = $subject->nextHSP) {
				push(@hsps, $hsp);
			}
			@hsps      = sort {$a->group <=> $b->group} @hsps;
			$max_group = $hsps[$#hsps]->group;

			# Store all HSPs with group, sbjct and score information

			for (my $group = 1; $group <= $max_group; $group++) {
				my @this_hsps = grep {$_->group == $group} @hsps;
				foreach my $hsp (@this_hsps) {
					if (pairagon::utility::hsp_validity($hsp, $queryLength) == -1) {
						next;
					}
					my $hsp_object = pairagon::hsp::new($subject_name, $hsp->sb, $hsp->se, $hsp->qb, $hsp->qe, $hsp->score, $hsp->group);
					if ($strand eq "-") {
						my $qb = $queryLength - $hsp->qb + 1;
						my $qe = $queryLength - $hsp->qe + 1;
						$hsp_object = pairagon::hsp::new($subject_name, $hsp->sb, $hsp->se, $qb, $qe, $hsp->score, $hsp->group);
					}
					push(@HSPS, $hsp_object);
				}
				$eligible_subjects{$subject_name} = $subject->length;
			}

		}

		# Now that you have all alignments from all subjects, get those that
		# are within 5% of the best alignment

		# Get the max_score

		my $max_score = 0;
		foreach my $e_subject (sort keys %eligible_subjects) {
			my $max_group = 0;
			my @hsps   = grep {$_->subject eq $e_subject} @HSPS;
			@hsps      = sort {$a->group <=> $b->group} @hsps;
			$max_group = $hsps[$#hsps]->group;

			for (my $group = 1; $group <= $max_group; $group++) {
				my @this_hsps = grep {$_->group == $group} @hsps;
				my $score     = 0;
				foreach my $hsp (@this_hsps) {
					$score += $hsp->score;
				}

				# Hack to make the pipeline choose non-random chromosomes if the seed alignments are 
				# identical in chrN and chrN_random
				# Make it 94% of its actual score, so it will be dropped if the same score existed in
				# a non-random chromosome. 

				if ($e_subject =~ /random/) {
					$score *= 0.94;
				}
				if ($score > $max_score) {
					$max_score = $score;
				}
				pairagon::utility::print_debug(5, "process_blast_output_file", "Sbjct = $e_subject, Score: $score");
			}
		}

		# Get everything within 5% of the best alignment

		my $seed_count = 0;
		foreach my $e_subject (sort keys %eligible_subjects) {
			my $max_group = 0;
			my @hsps   = grep {$_->subject eq $e_subject} @HSPS;
			@hsps      = sort {$a->group <=> $b->group} @hsps;
			$max_group = $hsps[$#hsps]->group;

			for (my $group = 1; $group <= $max_group; $group++) {
				my @this_hsps = sort {$a->sb <=> $b->sb} grep {$_->group == $group} @hsps;
				my $score     = 0;
				foreach my $hsp (@this_hsps) {
					$score += $hsp->score;
				}
				if ($score > 0.95*$max_score) {
					my @seed_hsps = ();
					foreach my $hsp_object (@this_hsps) {
						if (pairagon::utility::compatible_hsp($hsp_object, @seed_hsps)) {
							push(@seed_hsps, $hsp_object);
							@hsps = pairagon::utility::sort_genomic(@hsps);
						}
					}
					$seed{$cdna}{$seed_count}{"subject"} = $e_subject;
					$seed{$cdna}{$seed_count}{"sublen"}  = $eligible_subjects{$e_subject};
					$seed{$cdna}{$seed_count}{"score"}   = $score;
					$seed{$cdna}{$seed_count}{"strand"}  = $strand;
					$seed{$cdna}{$seed_count}{"hsps"}    = \@seed_hsps;
					$seed{$cdna}{$seed_count}{"gb_start"}= 1;
					$seed{$cdna}{$seed_count}{"gb_end"}  = 0;
					pairagon::utility::print_debug(3, "process_blast_output_file", "Best Sbjct = $e_subject, Score: $best_score");
					if (@seed_hsps > 0) { # NOT(Empty BLAST file, no alignment found)
						$seed{$cdna}{$seed_count}{"gb_start"}= $seed_hsps[0]->sb;
						$seed{$cdna}{$seed_count}{"gb_end"}  = $seed_hsps[$#seed_hsps]->se;
					}
					$seed_count++;
				}
			}
		}
	}

#foreach my $s (keys %seed) {
#	print_seed(\*STDOUT, $s, 10000, %{$seed{$s}});
#}
	return %seed;
}

sub clean_up {
	my $aligner = shift;
	my $prefix  = $aligner->output_dir."/".$aligner->instance_name;
	foreach my $suffix qw(fwd.blast rev.blast) {
		system("rm $prefix.$suffix");
	}
}

1;
}

#################################################
#  New seed alignment program handler goes here
#  as package pairagon::programX, subclass of
#  pairagon::aligner.
#  Check pairagon::blat and pairagon::wublast
#  to see how to implement it.
#
#
# To add a new seed alignment program PROGX:
# Write the following subroutines: 
# sub get_executables {}                    returns an array of executables that are needed
# sub get_check_seqdb_cmdline {}            returns a command that verifies a given seqdb
# sub align {}                                runs the program PROGX and generates a seed alignment 
#                                           structure in $object->{GLOBAL_SEED}
#
# The hash $object->{GLOBAL_SEED} looks like this:
#
#	foreach my $cdna (@names_of_cdnas_in_cdna_file) {
#		$seed{$cdna}{"subject"} = $subject;
#		$seed{$cdna}{"sublen"}  = $sub_len;
#		$seed{$cdna}{"score"}   = $score;
#		$seed{$cdna}{"strand"}  = $strand;
#		$seed{$cdna}{"gb_start"}= 16010501;
#		$seed{$cdna}{"gb_end"}  = 16040600;
#		my @hsps                = ();
#               push(@hsps, pairagon::hsp::new($subject, 16020501, 16020600, 1, 100, $score, $group));
#               push(@hsps, pairagon::hsp::new($subject, 16030501, 16030600, 101, 200, $score, $group));
#		$seed{$cdna}{"hsps"}    = \@hsps;
#	}
#
####################################################################################################################

####################
# Pairagon Instance
####################

{
package pairagon::instance;
use strict;
sub new {
	my $class = shift;
	my $self     = {@_};
	bless($self, $class);
	$self->{PAIRAGON}        = $self->program_dir."/pairagon";
	$self->{PAIRAGON2ESTGEN} = $self->program_dir."/pairagon2estgen";
	return $self
}

#####################################################################
# Check for executable files
#####################################################################
sub check_executables {
	print "# Checking Pairagon executables\n";
	my $pairagon = shift;
	my $prog_dir = $pairagon->program_dir;
	my $hmm_file = $pairagon->hmm_file;
	if (! -f "$prog_dir/pairagon") {
		die "Cannot find Pairagon executable (pairagon) in $prog_dir";
	}
	if (! -f "$prog_dir/pairagon2estgen") {
		die "Cannot find Pairagon output conversion executable (pairagon2estgen) in $prog_dir";
	}
	if (! -f "$hmm_file") {
		die "Cannot find Pairagon HMM parameter file $hmm_file";
	}
}

#####################################################################
# run Pairagon
#####################################################################
sub run {
	print "# Running Pairagon\n";
	my $pairagon = shift;
	my $command_line = $pairagon->get_alignment_command_line;
	print $PROGRESS_FH "$command_line\n";
	system($command_line) == 0 || die "Could not run ".$pairagon->pairagon;
	$command_line = $pairagon->get_conversion_command_line("estgen"); # I might make GTF/GFF output some day!
	print $PROGRESS_FH "$command_line\n";
	system($command_line) == 0 || die "Could not run ".$pairagon->pairagon2estgen;
}

#####################################################################
# command line to run executable using the options of this instance
#####################################################################
sub get_alignment_command_line {
	my $pairagon       = shift;
	my $executable     = $pairagon->pairagon;
	my $parameter_file = $pairagon->hmm_file;
	my $cdna_file      = $pairagon->cdna;
	my $genomic_file   = $pairagon->genomic;
	my $output_file    = $pairagon->state_output_file;
	my $seed_option    = "";
	my $alignment_mode = "";
	my $splice_mode    = "";
	my $optimized_mode = "";
	my $output_mode    = "";
	if ($pairagon->seed) {
		$seed_option = "--seed=".$pairagon->seed;
	}
	if ($pairagon->alignment_mode) {
		$alignment_mode = "--alignment_mode=".$pairagon->alignment_mode;
	}
	if ($pairagon->splice_mode) {
		$splice_mode = "--splice_mode=".$pairagon->splice_mode;
	}
	if ($pairagon->optimized_mode) {
		$optimized_mode = $pairagon->optimized_mode;
	}
	if ($pairagon->output_mode) {
		$output_mode = $pairagon->output_mode;
	}
	return "$executable $parameter_file $cdna_file $genomic_file $seed_option $alignment_mode $splice_mode $optimized_mode $output_mode > $output_file";
}

#####################################################################
# conversion to user friendly output
#####################################################################

sub get_conversion_command_line {
	my $pairagon = shift;
	my ($style) = @_;
	if ($style eq "estgen") {
		return $pairagon->get_estgen_conversion_command_line;
	} else {
		die "Cannot convert the state sequence to $style style output.";
	}
}

#####################################################################
# conversion to est2genome style output
#####################################################################
sub get_estgen_conversion_command_line {
	my $pairagon     = shift;
	my $executable   = $pairagon->pairagon2estgen;
	my $cdna_file    = $pairagon->cdna;
	my $genomic_file = $pairagon->genomic;
	my $input_file   = $pairagon->state_output_file;
	my $output_file  = $pairagon->estgen_output_file;
	return "$executable $input_file -cdna=$cdna_file -genomic=$genomic_file > $output_file";
}

# Hardcoded

sub pairagon        {shift->{PAIRAGON}}
sub pairagon2estgen {shift->{PAIRAGON2ESTGEN}}

# Set via new() call

sub program_dir     {shift->{PROGRAM_DIR}}
sub hmm_file        {shift->{HMM_FILE}}
sub cdna            {shift->{CDNA}}
sub genomic         {shift->{GENOMIC}}
sub seed            {shift->{SEED}}
sub alignment_mode  {shift->{ALIGNMENT_MODE}}
sub splice_mode     {shift->{SPLICE_MODE}}
sub optimized_mode  {shift->{OPTIMIZED_MODE}}
sub output_mode     {shift->{OUTPUT_MODE}}
sub output_dir      {shift->{OUTPUT_DIR}}
sub instance_name   {shift->{INSTANCE_NAME}}

sub state_output_file {
	my $self = shift;
	$self->output_dir."/".$self->instance_name.".pair";
}

sub estgen_output_file {
	my $self = shift;
	$self->output_dir."/".$self->instance_name.".estgen";
}
1;
}

################
# hsp
################

{
package pairagon::hsp;
use strict;
use overload '""' => '_overload';

sub new {
	my $hsp = bless {};
	($hsp->{SUBJECT}, $hsp->{SB}, $hsp->{SE}, $hsp->{QB}, $hsp->{QE}, $hsp->{SCORE}, $hsp->{GROUP}) = @_;
	return $hsp;
}

sub _overload {
	my $hsp = shift;
	return "(".$hsp->sb.", ".$hsp->qb.") (".$hsp->se.", ".$hsp->qe.")";
}

sub subject         {shift->{SUBJECT}}
sub score           {shift->{SCORE}}
sub group           {shift->{GROUP}}
sub qb              {shift->{QB}}
sub qe              {shift->{QE}}
sub sb              {shift->{SB}}
sub se              {shift->{SE}}
1;
}
